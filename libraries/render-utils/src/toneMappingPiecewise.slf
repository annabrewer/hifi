<@include gpu/Config.slh@>
<$VERSION_HEADER$>
//
//  toneMappingPiecewise.frag
//
//  Draw texture 0 fetched at texcoord.xy
//
//  Created by Anna Brewer on 7/30/2019
//  Copyright 2019 High Fidelity, Inc.
//
//  Piecewise tone curve was adapted from John Hable's sample code:
//  https://github.com/johnhable/fw-public.git
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

<@include render-utils/ShaderConstants.h@>
<@include ToneMappingCommon.h@>

LAYOUT(binding=RENDER_UTILS_BUFFER_TM_PARAMS) uniform toneMappingParamsBuffer {
    Parameters allParams;
};

int getChannelMode() {
    return allParams._globals._channelMode;
}

float getTwoPowExposure() {
    return allParams._globals._twoPowExposure;
}

float getToeLnA(CurveParams params) {
    return params._toeLnA;
}
float getToeB(CurveParams params) {
    return params._toeB;
}
float getToeScaleY(CurveParams params) {
    return params._toeScaleY;
}
float getShoulderOffsetY(CurveParams params) {
    return params._shoulderOffsetY;
}

float getShoulderLnA(CurveParams params) {
    return params._shoulderLnA;
}
float getShoulderB(CurveParams params) {
    return params._shoulderB;
}
float getShoulderOffsetX(CurveParams params) {
    return params._shoulderOffsetX;
}
float getShoulderScaleY(CurveParams params) {
    return params._shoulderScaleY;
}

float getLinearLnA(CurveParams params) {
    return params._linearLnA;
}
float getLinearB(CurveParams params) {
    return params._linearB;
}
float getLinearOffsetX(CurveParams params) {
    return params._linearOffsetX;
}
float getLinearScaleY(CurveParams params) {
    return params._linearScaleY;
}

float getX0(CurveParams params) {
    return params._fullCurveX0;
}
float getY0(CurveParams params) {
    return params._fullCurveY0;
}
float getX1(CurveParams params) {
    return params._fullCurveX1;
}
float getY1(CurveParams params) {
    return params._fullCurveY1;
}

float getW(CurveParams params) {
    return params._fullCurveW;
}
float getInvW(CurveParams params) {
    return params._fullCurveInvW;
}

CurveSegment m_segments[12];

LAYOUT(binding=RENDER_UTILS_TEXTURE_TM_COLOR) uniform sampler2D colorMap;

layout(location=0) in vec2 varTexCoord0;
layout(location=0) out vec4 outFragColor;

float EvalCurveSegment(CurveSegment curve, float x) {
    float x0 = (x - curve.m_offsetX) * curve.m_scaleX;
    float y0 = 0.0f;

    // log(0) is undefined but our function should evaluate to 0. There are better ways to handle this,
    // but it's doing it the slow way here for clarity.
    if (x0 > 0)
    {
        y0 = exp(curve.m_lnA + curve.m_B * log(x0));
    }

    return y0 * curve.m_scaleY + curve.m_offsetY;
}

float EvalFullCurve(FullCurve curve, float srcX, int curveIndex) {
    float normX = srcX * curve.m_invW;
    int index = (normX < curve.m_x0) ? 0 : ((normX < curve.m_x1) ? 1 : 2);
    CurveSegment segment = m_segments[curveIndex * 3 + index];
    float ret = EvalCurveSegment(segment, normX);
    return ret;
}

void main(void) {
<@if HIFI_USE_MIRRORED@>
    vec4 fragColorRaw = texture(colorMap, vec2(1.0 - varTexCoord0.x, varTexCoord0.y));
<@else@>
    vec4 fragColorRaw = texture(colorMap, varTexCoord0);
<@endif@>
    vec3 fragColor = fragColorRaw.xyz;
    vec3 srcColor = fragColor * getTwoPowExposure();

    int channelMode = getChannelMode();

    int start = channelMode == 0 ? 0 : 1;
    int end = channelMode == 0 ? 1 : 4;

    // curve evaluations for R, G and B values
    // if in global mode they are all evaluated using global curve
    // if in spectral mode each channel is evaluated using its own curve
    float curveVals[3];

    for (int i = start; i < end; i++) {
        
        CurveParams p;
        
        if (i == 0) { p = allParams._globalParams; }
        else if (i == 1) { p = allParams._redParams; }
        else if (i == 2) { p = allParams._greenParams; }
        else { p = allParams._blueParams; }

        FullCurve curve = FullCurve(getW(p), getInvW(p), getX0(p), getY0(p), getX1(p), getY1(p));

        m_segments[i * 3] = CurveSegment(0.0, 0.0, 1.0, getToeScaleY(p), getToeLnA(p), getToeB(p));
        m_segments[i * 3 + 1] = CurveSegment(getLinearOffsetX(p), 0.0, 1.0, getLinearScaleY(p), getLinearLnA(p), getLinearB(p));
        m_segments[i * 3 + 2] = CurveSegment(getShoulderOffsetX(p), getShoulderOffsetY(p), -1.0, getShoulderScaleY(p), getShoulderLnA(p), getShoulderB(p));

        if (channelMode == 0) {
            curveVals[0] = EvalFullCurve(curve, srcColor.x, i);
            curveVals[1] = EvalFullCurve(curve, srcColor.y, i);
            curveVals[2] = EvalFullCurve(curve, srcColor.z, i);
        }
        else {
            curveVals[i - 1] = EvalFullCurve(curve, srcColor[i - 1], i);
        }
        
    }

    outFragColor = vec4(curveVals[0], curveVals[1], curveVals[2], 1.0);

}