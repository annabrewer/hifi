<@include gpu/Config.slh@>
<$VERSION_HEADER$>
//  Generated on Sat Oct 24 09:34:37 2015
//
//  toneMappingPiecewise.frag
//
//  Draw texture 0 fetched at texcoord.xy
//
//  Created by Anna Brewer on 7/30/2019
//  Copyright 2019 High Fidelity, Inc.
//
//  Adapted from John Hable's piecewise filmic curve sample code:
//  https://github.com/johnhable/fw-public.git
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

<@include render-utils/ShaderConstants.h@>
<@include ToneMappingCommon.h@>

LAYOUT(binding=RENDER_UTILS_BUFFER_TM_PARAMS) uniform toneMappingParamsBuffer {
    Parameters params;
};

float getTwoPowExposure() {
    return params._globals._twoPowExposure;
}

float getToeLnA() {
    return params._redParams._toeLnA;
}
float getToeB() {
    return params._redParams._toeB;
}
float getToeScaleY() {
    return params._redParams._toeScaleY;
}
float getShoulderOffsetY() {
    return params._redParams._shoulderOffsetY;
}

float getShoulderLnA() {
    return params._redParams._shoulderLnA;
}
float getShoulderB() {
    return params._redParams._shoulderB;
}
float getShoulderOffsetX() {
    return params._redParams._shoulderOffsetX;
}
float getShoulderScaleY() {
    return params._redParams._shoulderScaleY;
}

float getLinearLnA() {
    return params._redParams._linearLnA;
}
float getLinearB() {
    return params._redParams._linearB;
}
float getLinearOffsetX() {
    return params._redParams._linearOffsetX;
}
float getLinearScaleY() {
    return params._redParams._linearScaleY;
}

float getX0() {
    return params._redParams._fullCurveX0;
}
float getY0() {
    return params._redParams._fullCurveY0;
}
float getX1() {
    return params._redParams._fullCurveX1;
}
float getY1() {
    return params._redParams._fullCurveY1;
}

float getW() {
    return params._redParams._fullCurveW;
}
float getInvW() {
    return params._redParams._fullCurveInvW;
}

CurveSegment m_segments[3];

LAYOUT(binding=RENDER_UTILS_TEXTURE_TM_COLOR) uniform sampler2D colorMap;

layout(location=0) in vec2 varTexCoord0;
layout(location=0) out vec4 outFragColor;

float EvalCurveSegment(CurveSegment curve, float x) {
    float x0 = (x - curve.m_offsetX) * curve.m_scaleX;
    float y0 = 0.0f;

    // log(0) is undefined but our function should evaluate to 0. There are better ways to handle this,
    // but it's doing it the slow way here for clarity.
    if (x0 > 0)
    {
        y0 = exp(curve.m_lnA + curve.m_B * log(x0));
    }

    return y0 * curve.m_scaleY + curve.m_offsetY;
}

float EvalFullCurve(FullCurve curve, float srcX) {
    float normX = srcX * curve.m_invW;
    int index = (normX < curve.m_x0) ? 0 : ((normX < curve.m_x1) ? 1 : 2);
    CurveSegment segment = m_segments[index];
    float ret = EvalCurveSegment(segment, normX);
    return ret;
}

void main(void) {
<@if HIFI_USE_MIRRORED@>
    vec4 fragColorRaw = texture(colorMap, vec2(1.0 - varTexCoord0.x, varTexCoord0.y));
<@else@>
    vec4 fragColorRaw = texture(colorMap, varTexCoord0);
<@endif@>
    vec3 fragColor = fragColorRaw.xyz;
    vec3 srcColor = fragColor * getTwoPowExposure();

    FullCurve curve = FullCurve(getW(), getInvW(), getX0(), getY0(), getX1(), getY1());

    m_segments[0] = CurveSegment(0.0, 0.0, 1.0, getToeScaleY(), getToeLnA(), getToeB());
    m_segments[1] = CurveSegment(getLinearOffsetX(), 0.0, 1.0, getLinearScaleY(), getLinearLnA(), getLinearB());
    m_segments[2] = CurveSegment(getShoulderOffsetX(), getShoulderOffsetY(), -1.0, getShoulderScaleY(), getShoulderLnA(), getShoulderB());

    float curveValR = EvalFullCurve(curve, srcColor.x);
    float curveValG = EvalFullCurve(curve, srcColor.y);
    float curveValB = EvalFullCurve(curve, srcColor.z);

    outFragColor = vec4(getX0(), getX1(), 0.0, 1.0);
}