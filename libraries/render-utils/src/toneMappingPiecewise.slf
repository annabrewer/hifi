<@include gpu/Config.slh@>
<$VERSION_HEADER$>
//  Generated on Sat Oct 24 09:34:37 2015
//
//  toneMappingPiecewise.frag
//
//  Draw texture 0 fetched at texcoord.xy
//
//  Created by Anna Brewer on 7/30/2019
//  Copyright 2019 High Fidelity, Inc.
//
//  Adapted from John Hable's piecewise filmic curve sample code:
//  https://github.com/johnhable/fw-public.git
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

<@include render-utils/ShaderConstants.h@>

struct ToneMappingParams {
    vec4 _shoulderOffsetX_shoulderOffsetY_shoulderLnA_shoulderB;
    vec4 _toeLnA_toeB_linearLnA_linearB;
    vec4 _linearOffsetX_2powExp_w_invW;
    vec4 _x0_y0_x1_y1;
    vec4 _toeScaleY_linearScaleY_shoulderScaleY_s3;
    ivec4 toneCurve_s0_s1_s2;
};

struct CurveSegment {
	float m_offsetX;
	float m_offsetY;
	float m_scaleX; // always 1 or -1
	float m_scaleY;
	float m_lnA;
	float m_B;
};

struct FullCurve
{
	float m_W;
	float m_invW;

	float m_x0;
	float m_y0;
    float m_x1;
	float m_y1;
};

CurveSegment m_segments[3];

LAYOUT(binding=RENDER_UTILS_BUFFER_TM_PARAMS) uniform toneMappingParamsBuffer {
    ToneMappingParams params;
};

float getToeLnA() {
    return params._toeLnA_toeB_linearLnA_linearB.x;
}
float getToeB() {
    return params._toeLnA_toeB_linearLnA_linearB.y;
}
float getLinearLnA() {
    return params._toeLnA_toeB_linearLnA_linearB.z;
}
float getLinearB() {
    return params._toeLnA_toeB_linearLnA_linearB.w;
}

float getShoulderOffsetX() {
    return params._shoulderOffsetX_shoulderOffsetY_shoulderLnA_shoulderB.x;
}
float getShoulderOffsetY() {
    return params._shoulderOffsetX_shoulderOffsetY_shoulderLnA_shoulderB.y;
}
float getShoulderLnA() {
    return params._shoulderOffsetX_shoulderOffsetY_shoulderLnA_shoulderB.z;
}
float getShoulderB() {
    return params._shoulderOffsetX_shoulderOffsetY_shoulderLnA_shoulderB.w;
}

float getLinearOffsetX() {
    return params._linearOffsetX_2powExp_w_invW.x;
}
float getTwoPowExposure() {
    return params._linearOffsetX_2powExp_w_invW.y;
}
float getW() {
    return params._linearOffsetX_2powExp_w_invW.z;
}
float getInvW() {
    return params._linearOffsetX_2powExp_w_invW.w;
}

float getX0() {
    return params._x0_y0_x1_y1.x;
}
float getY0() {
    return params._x0_y0_x1_y1.y;
}
float getX1() {
    return params._x0_y0_x1_y1.z;
}
float getY1() {
    return params._x0_y0_x1_y1.w;
}

float getToeScaleY() {
    return params._toeScaleY_linearScaleY_shoulderScaleY_s3.x;
}

float getLinearScaleY() {
    return params._toeScaleY_linearScaleY_shoulderScaleY_s3.y;
}

float getShoulderScaleY() {
    return params._toeScaleY_linearScaleY_shoulderScaleY_s3.z;
}

LAYOUT(binding=RENDER_UTILS_TEXTURE_TM_COLOR) uniform sampler2D colorMap;

layout(location=0) in vec2 varTexCoord0;
layout(location=0) out vec4 outFragColor;

float EvalCurveSegment(CurveSegment curve, float x) {
    float x0 = (x - curve.m_offsetX)*curve.m_scaleX;
	float y0 = 0.0f;

	// log(0) is undefined but our function should evaluate to 0. There are better ways to handle this,
	// but it's doing it the slow way here for clarity.
	if (x0 > 0)
	{
		y0 = exp(curve.m_lnA + curve.m_B*log(x0));
	}

	return y0*curve.m_scaleY + curve.m_offsetY;
}

float EvalFullCurve(FullCurve curve, float srcX) {
	float normX = srcX * curve.m_invW;
	int index = (normX < curve.m_x0) ? 0 : ((normX < curve.m_x1) ? 1 : 2);
	CurveSegment segment = m_segments[index];
	float ret = EvalCurveSegment(segment, normX);
	return ret;
}

void main(void) {
<@if HIFI_USE_MIRRORED@>
    vec4 fragColorRaw = texture(colorMap, vec2(1.0 - varTexCoord0.x, varTexCoord0.y));
<@else@>
    vec4 fragColorRaw = texture(colorMap, varTexCoord0);
<@endif@>
    vec3 fragColor = fragColorRaw.xyz;
    vec3 srcColor = fragColor * getTwoPowExposure();

    FullCurve curve = FullCurve(getW(), getInvW(), getX0(), getY0(), getX1(), getY1());

    m_segments[0] = CurveSegment(0.0, 0.0, 1.0, getToeScaleY(), getToeLnA(), getToeB());
    m_segments[1] = CurveSegment(getLinearOffsetX(), 0.0, 1.0, getLinearScaleY(), getLinearLnA(), getLinearB());
    m_segments[2] = CurveSegment(getShoulderOffsetX(), getShoulderOffsetY(), -1.0, getShoulderScaleY(), getShoulderLnA(), getShoulderB());

    float curveValR = EvalFullCurve(curve, srcColor.x);
    float curveValG = EvalFullCurve(curve, srcColor.y);
    float curveValB = EvalFullCurve(curve, srcColor.z);

    outFragColor = vec4(curveValR, curveValG, curveValB, 1.0);
}
