<@include gpu/Config.slh@>
<$VERSION_HEADER$>
//  Generated on Sat Oct 24 09:34:37 2015
//
//  toneMappingPiecewise.frag
//
//  Draw texture 0 fetched at texcoord.xy
//
//  Created by Anna Brewer on 7/30/2019
//  Copyright 2019 High Fidelity, Inc.
//
//  Adapted from John Hable's piecewise filmic curve sample code:
//  https://github.com/johnhable/fw-public.git
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

<@include render-utils/ShaderConstants.h@>
<@include ToneMappingCommon.h@>

LAYOUT(binding=RENDER_UTILS_BUFFER_TM_PARAMS) uniform toneMappingParamsBuffer {
    ToneMappingParams params;
};

float getTwoPowExposure() {
    return params._exp_2powExp_s0_s1.y;
}

float getToeLnA() {
    return params._toeLnA_toeB_toeScaleY_shoulderOffsetY.x;
}
float getToeB() {
    return params._toeLnA_toeB_toeScaleY_shoulderOffsetY.y;
}
float getToeScaleY() {
    return params._toeLnA_toeB_toeScaleY_shoulderOffsetY.z;
}
float getShoulderOffsetY() {
    return params._toeLnA_toeB_toeScaleY_shoulderOffsetY.w;
}

float getShoulderLnA() {
    return params._shoulderLnA_shoulderB_shoulderOffsetX_shoulderScaleY.x;
}
float getShoulderB() {
    return params._shoulderLnA_shoulderB_shoulderOffsetX_shoulderScaleY.y;
}
float getShoulderOffsetX() {
    return params._shoulderLnA_shoulderB_shoulderOffsetX_shoulderScaleY.z;
}
float getShoulderScaleY() {
    return params._shoulderLnA_shoulderB_shoulderOffsetX_shoulderScaleY.w;
}

float getLinearLnA() {
    return params._linearLnA_linearB_linearOffsetX_linearScaleY.x;
}
float getLinearB() {
    return params._linearLnA_linearB_linearOffsetX_linearScaleY.y;
}
float getLinearOffsetX() {
    return params._linearLnA_linearB_linearOffsetX_linearScaleY.z;
}
float getLinearScaleY() {
    return params._linearLnA_linearB_linearOffsetX_linearScaleY.w;
}

float getX0() {
    return params._fullCurveX0_fullCurveY0_fullCurveX1_fullCurveY1.x;
}
float getY0() {
    return params._fullCurveX0_fullCurveY0_fullCurveX1_fullCurveY1.y;
}
float getX1() {
    return params._fullCurveX0_fullCurveY0_fullCurveX1_fullCurveY1.z;
}
float getY1() {
    return params._fullCurveX0_fullCurveY0_fullCurveX1_fullCurveY1.w;
}

float getW() {
    return params._fullCurveW_fullCurveInvW_s0_s1.x;
}
float getInvW() {
    return params._fullCurveW_fullCurveInvW_s0_s1.y;
}

CurveSegment m_segments[3];

LAYOUT(binding=RENDER_UTILS_TEXTURE_TM_COLOR) uniform sampler2D colorMap;

layout(location=0) in vec2 varTexCoord0;
layout(location=0) out vec4 outFragColor;

float EvalCurveSegment(CurveSegment curve, float x) {
    float x0 = (x - curve.m_offsetX) * curve.m_scaleX;
    float y0 = 0.0f;

    // log(0) is undefined but our function should evaluate to 0. There are better ways to handle this,
    // but it's doing it the slow way here for clarity.
    if (x0 > 0)
    {
        y0 = exp(curve.m_lnA + curve.m_B * log(x0));
    }

    return y0 * curve.m_scaleY + curve.m_offsetY;
}

float EvalFullCurve(FullCurve curve, float srcX) {
    float normX = srcX * curve.m_invW;
    int index = (normX < curve.m_x0) ? 0 : ((normX < curve.m_x1) ? 1 : 2);
    CurveSegment segment = m_segments[index];
    float ret = EvalCurveSegment(segment, normX);
    return ret;
}

void main(void) {
<@if HIFI_USE_MIRRORED@>
    vec4 fragColorRaw = texture(colorMap, vec2(1.0 - varTexCoord0.x, varTexCoord0.y));
<@else@>
    vec4 fragColorRaw = texture(colorMap, varTexCoord0);
<@endif@>
    vec3 fragColor = fragColorRaw.xyz;
    vec3 srcColor = fragColor * getTwoPowExposure();

    FullCurve curve = FullCurve(getW(), getInvW(), getX0(), getY0(), getX1(), getY1());

    m_segments[0] = CurveSegment(0.0, 0.0, 1.0, getToeScaleY(), getToeLnA(), getToeB());
    m_segments[1] = CurveSegment(getLinearOffsetX(), 0.0, 1.0, getLinearScaleY(), getLinearLnA(), getLinearB());
    m_segments[2] = CurveSegment(getShoulderOffsetX(), getShoulderOffsetY(), -1.0, getShoulderScaleY(), getShoulderLnA(), getShoulderB());

    float curveValR = EvalFullCurve(curve, srcColor.x);
    float curveValG = EvalFullCurve(curve, srcColor.y);
    float curveValB = EvalFullCurve(curve, srcColor.z);

    outFragColor = vec4(curveValR, curveValG, curveValB, 1.0);
}