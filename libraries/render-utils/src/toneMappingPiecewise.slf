<@include gpu/Config.slh@>
<$VERSION_HEADER$>
//  Generated on Sat Oct 24 09:34:37 2015
//
//  toneMappingPiecewise.frag
//
//  Draw texture 0 fetched at texcoord.xy
//
//  Created by Anna Brewer on 7/30/2019
//  Copyright 2019 High Fidelity, Inc.
//
//  Adapted from John Hable's piecewise filmic curve sample code:
//  https://github.com/johnhable/fw-public.git
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

<@include render-utils/ShaderConstants.h@>

struct ToneMappingParams {
    vec4 _shoulderOffsetX_shoulderOffsetY_shoulderLnA_shoulderB;
    vec4 _toeLnA_toeB_linearLnA_linearB;
    vec4 _linearOffsetX_2powExp_w_invW;
    vec4 _x0_y0_x1_y1;
    ivec4 curve_s0_s1_s2;
};

struct CurveSegment {
    float m_offsetX;
    float m_offsetY;
    float m_scaleX; // always 1 or -1
    float m_scaleY;
    float m_lnA;
    float m_B;
};

struct FullCurve
{
	float m_W;
	float m_invW;

	float m_x0;
	float m_x1;
	float m_y0;
	float m_y1;
};

CurveSegment m_segments[3];

LAYOUT(binding=RENDER_UTILS_BUFFER_TM_PARAMS) uniform toneMappingParamsBuffer {
    ToneMappingParams params;
};

float getToeLnA() {
    return params._toeLnA_toeB_linearLnA_linearB.x;
}
float getToeB() {
    return params._toeLnA_toeB_linearLnA_linearB.y;
}
float getLinearLnA() {
    return params._toeLnA_toeB_linearLnA_linearB.z;
}
float getLinearB() {
    return params._toeLnA_toeB_linearLnA_linearB.w;
}

float getShoulderOffsetX() {
    return params._shoulderOffsetX_shoulderOffsetY_shoulderLnA_shoulderB.x;
}
float getShoulderOffsetY() {
    return params._shoulderOffsetX_shoulderOffsetY_shoulderLnA_shoulderB.y;
}
float getShoulderLnA() {
    return params._shoulderOffsetX_shoulderOffsetY_shoulderLnA_shoulderB.z;
}
float getShoulderB() {
    return params._shoulderOffsetX_shoulderOffsetY_shoulderLnA_shoulderB.w;
}

float getLinearOffsetX() {
    return params._linearOffsetX_2powExp_w_invW.x;
}
float getTwoPowExposure() {
    return params._linearOffsetX_2powExp_w_invW.y;
}
float getW() {
    return params._linearOffsetX_2powExp_w_invW.z;
}
float getInvW() {
    return params._linearOffsetX_2powExp_w_invW.w;
}

float getX0() {
    return params._x0_y0_x1_y1.x;
}
float getY0() {
    return params._x0_y0_x1_y1.y;
}
float getX1() {
    return params._x0_y0_x1_y1.z;
}
float getY1() {
    return params._x0_y0_x1_y1.w;
}

LAYOUT(binding=RENDER_UTILS_TEXTURE_TM_COLOR) uniform sampler2D colorMap;

layout(location=0) in vec2 varTexCoord0;
layout(location=0) out vec4 outFragColor;

float EvalCurveSegment(CurveSegment curve, float x) {
    float x0 = (x - curve.m_offsetX)*curve.m_scaleX;
	float y0 = 0.0f;

	// log(0) is undefined but our function should evaluate to 0. There are better ways to handle this,
	// but it's doing it the slow way here for clarity.
	if (x0 > 0)
	{
		y0 = exp(curve.m_lnA + curve.m_B*log(x0));
	}

	return y0*curve.m_scaleY + curve.m_offsetY;
}

float EvalInvCurveSegment(CurveSegment curve, float y) {
	float y0 = (y-curve.m_offsetY)/curve.m_scaleY;
	float x0 = 0.0f;
	
	// watch out for log(0) again
	if (y0 > 0)
	{
		x0 = exp((log(y0) - curve.m_lnA)/curve.m_B);
	}
	
    float x = x0/curve.m_scaleX + curve.m_offsetX;

    return x;
}

float EvalFullCurve(FullCurve curve, float srcX) {
	float normX = srcX * curve.m_invW;
	int index = (normX < curve.m_x0) ? 0 : ((normX < curve.m_x1) ? 1 : 2);
	CurveSegment segment = m_segments[index];
	float ret = EvalCurveSegment(segment, normX);
	return ret;
}

float EvalInvFullCurve(FullCurve curve, float y) {
	int index = (y < curve.m_y0) ? 0 : ((y < curve.m_y1) ? 1 : 2);
	CurveSegment segment = m_segments[index];

	float normX = EvalInvCurveSegment(segment, y);
	return normX * curve.m_W;
}

// convert to y=mx+b
float[2] AsSlopeIntercept(float x0, float x1, float y0, float y1) {
	float dy = (y1-y0);
	float dx = (x1-x0);
    float m;
	if (dx == 0)
		m = 1.0f;
	else
		m = dy/dx;

	float b = y0 - x0*m;

    float mb[2];
    mb[0] = m;
    mb[1] = b;
    return mb;
}

void main(void) {
// using the inverse gamma (so that higher gamma = brighter) flips the image for some reason, so we flip it back here
<@if HIFI_USE_MIRRORED@>
    vec4 fragColorRaw = texture(colorMap, varTexCoord0);
<@else@>
    vec4 fragColorRaw = texture(colorMap, vec2(1.0 - varTexCoord0.x, varTexCoord0.y));
<@endif@>

    FullCurve curve = FullCurve(getW(), getInvW(), getX0(), getY0(), getX1(), getY1());

    float m_offsetX;
    float m_offsetY;
    float m_scaleX; // always 1 or -1
    float m_scaleY;
    float m_lnA;
    float m_B;

    m_segments[0] = CurveSegment(0.0, 0.0, 1.0, 1.0, getToeLnA(), getToeB());
    m_segments[1] = CurveSegment(getLinearOffsetX(), 0.0, 1.0, 1.0, getLinearLnA(), getLinearB());
    m_segments[2] = CurveSegment(getShoulderOffsetX(), getShoulderOffsetY(), -1.0, -1.0, getShoulderLnA(), getShoulderB());

    vec3 fragColor = fragColorRaw.xyz;

    vec3 srcColor = fragColor * getTwoPowExposure();

    float curveValR = EvalFullCurve(curve, srcColor.x);
    float curveValG = EvalFullCurve(curve, srcColor.y);
    float curveValB = EvalFullCurve(curve, srcColor.z);

    outFragColor = vec4(curveValR, curveValG, curveValB, 1.0);
}
